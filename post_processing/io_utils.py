import os
import sys
import warnings

import datetime
import numpy as np
from skimage import measure

np.set_printoptions(threshold=sys.maxsize)

class PostprocessUtils:

    @staticmethod
    def apply_postprocessing(mat_in, cfg=None):
        _pp_method = cfg.get('post_process', None)
        mat_out = eval('PostprocessUtils.' + _pp_method + '(mat_in, cfg)')
        return mat_out

    @staticmethod
    def denoise_label(input_label, cfg=None):
        """ Denoise annotation files generated by blender
        Args:
            input_label: 
            num_classes:
        Returns:
        """
        # TODO fill out doc string
        num_classes = cfg.get('num_classes', None)
    
        _step = num_classes/255.0 #TODO rename
    
        # apply binning on label values -> denoise
        _label = np.round(input_label * _step).astype(int)

        # decode labels from image values
        _out = _label[:,:,0] + _label[:,:,1] * num_classes + _label[:,:,2] * num_classes**2
        return _out

    @staticmethod
    def trim_channels(_map, cfg=None):
        return _map[:,:,0] 

class LabelFilter:

    @staticmethod
    def filter_by_depth(mask, filter_cfg, **kwargs):
        """
        """
        _data = kwargs["data"]
        min_depth = filter_cfg.get("min_depth",0) 
        max_depth = filter_cfg.get("max_depth",1e09) 
        depth_map = _data[filter_cfg["depth_key"]]
        thres_type = filter_cfg.get("thres_type","avg")

        if thres_type == "avg":
            thres = np.mean(depth_map[mask])
        elif thres_type == "min":
            thres = np.amin(depth_map[mask])
        elif thres_type == "max":
            thres = np.amax(depth_map[mask])

        if thres > max_depth or thres < min_depth:
            return True

        return False 

    @staticmethod
    def filter_by_area(mask, filter_cfg, **kwargs):
        """
        """
        min_area = filter_cfg.get("min_area",0) 
        max_area = filter_cfg.get("max_area",1e09) 

        _area = np.sum(mask)
        if _area < min_area or _area > max_area:
            return True

        return False


class CocoUtils:
    # adapted from : https://github.com/waspinator/pycococreator

    @staticmethod
    def close_contour(contour):
        """ Ensures the contour to be closed.
        Args:
            contour: contour to close.
        Returns:
            closed contour
        """
        if not np.array_equal(contour[0], contour[-1]):
            contour = np.vstack((contour, contour[0]))
        return contour

    @staticmethod
    def binary_mask_to_rle(binary_mask):
        """Converts a binary mask to RLE (Run Length Encoding)
        Args:
            binary_mask: a 2D binary numpy array where '1's represent the object
        Returns:
            RLE of binary mask.
        """

        rle = {'counts': [], 'size': list(binary_mask.shape)}
        counts = rle.get('counts')
        for i, (value, elements) in enumerate(groupby(binary_mask.ravel(order='F'))):
            if i == 0 and value == 1:
                    counts.append(0)
            counts.append(len(list(elements)))

        return rle

    @staticmethod
    def binary_mask_to_polygon(binary_mask, tolerance=0):
        """Converts a binary mask to COCO polygon representation
        Args:
            binary_mask: a 2D binary numpy array where '1's represent the object
            tolerance: Maximum distance from original points of polygon to approximated
        Returns:
            polygonal chain. If tolerance is 0, the original coordinate array is returned.
        """
        polygons = []
        # pad mask to close contours of shapes which start and end at an edge
        padded_binary_mask = np.pad(binary_mask, pad_width=1, mode='constant', constant_values=0)
        contours = measure.find_contours(padded_binary_mask, 0.5)
        contours = np.subtract(contours, 1)
        for contour in contours:
            contour = CocoUtils.close_contour(contour)
            contour = measure.approximate_polygon(contour, tolerance)
            if len(contour) < 3:
                continue
            contour = np.flip(contour, axis=1)
            segmentation = contour.ravel().tolist()
            # after padding and subtracting 1 we may get -0.5 points in our segmentation
            segmentation = [0 if i < 0 else i for i in segmentation]
            polygons.append(segmentation)

        return polygons

    @staticmethod
    def binary_mask_to_bbox(binary_mask, tolerance=0):
        """ Computes smallest bounding box containing the binary mask.

        Args:
            binary_mask: binary mask on which base the bbox is computed
        Returns:
            bbox: [x,y, width, height]
        """
        # get columns and rows that contain 1s
        rows = np.any(binary_mask, axis=1)
        cols = np.any(binary_mask, axis=0)

        # Find the min and max col/row index that contain 1s
        row_min, row_max = np.where(rows)[0][[0, -1]]
        col_min, col_max = np.where(cols)[0][[0, -1]]

        # compute height and width of bbox
        height = row_max - row_min + 1
        width = col_max - col_min + 1
        return [int(col_min), int(row_min), int(width), int(height)]

    @staticmethod
    def create_image_info(image_id, file_name, image_size,
                      date_captured=datetime.datetime.utcnow().isoformat(' '),
                      license_id=1, coco_url="", flickr_url="", aux_channel=""):
        """ Creates image info in coco format
        Args:
            image_id: integer to uniquly identify image
            file_name: filename for image
            image_size: The size of the image, given as [W, H]

        Returns:
            dict with coco image info
        """

        image_info = {
            "id": image_id,
            "file_name": file_name,
            "width": image_size[1],
            "height": image_size[0],
            "date_captured": date_captured,
            "license": license_id,
            "coco_url": coco_url,
            "flickr_url": flickr_url,
            "auxillary": aux_channel
        }

        return image_info

    @staticmethod
    def create_annotation_info(annotation_id, image_id, category_info, binary_mask,  tolerance=2, bounding_box=None):
        """Creates info section of coco annotation
        Args:
            annotation_id: integer to uniquly identify the annotation
            image_id: integer to uniquly identify image
            category_info containing category id and is_crowd flag
            binary_mask: A binary image mask of the object with the shape [H, W].
            tolerance: The tolerance for fitting polygons to the objects mask.
            bounding_box: 
        """
        area = binary_mask.sum().tolist()
        if area < 1:
            return None

        if bounding_box is None:
            bounding_box = CocoUtils.binary_mask_to_bbox(binary_mask)
    
        if category_info["is_crowd"]:
            segmentation = CocoUtils.binary_mask_to_rle(binary_mask)
        else :
            segmentation = CocoUtils.binary_mask_to_polygon(binary_mask, tolerance)
            if not segmentation:
                return None

        annotation_info = {
            "id": annotation_id,
            "image_id": image_id,
            "category_id": category_info["id"],
            "iscrowd": category_info["is_crowd"],
            "area": area,
            "bbox": bounding_box,
            "segmentation": segmentation,
            "width": binary_mask.shape[1],
            "height": binary_mask.shape[0],
        } 
    
        return annotation_info



